#include <WiFiManager.h> 
#include <HTTPClient.h>
#include <OneWire.h>
#include <DallasTemperature.h>
#include <ArduinoJson.h>
#include <Preferences.h>
#include <Wire.h>
#include <Adafruit_ADS1X15.h>

// --- PINES ---
const int oneWireBus = 4; 
const int PIN_COMP = 26;
const int PIN_EVAP = 27;
const int PIN_COND = 14;
const int PIN_HEAT = 12;

// RELAY MASTER (Fail-Safe: Usamos el contacto NC)
const int PIN_REEFER = 13;

// --- VARIABLES ---
char device_id[50] = "alejandra1"; 
String serverUrl = "https://reefermonitor.com.ar/api/datos"; // Actualizado a tu dominio seguro

// Temporizador para el Watchdog (Perro Guardi√°n) de WiFi
unsigned long ultimo_wifi_ok = 0; 

// --- OBJETOS ---
OneWire oneWire(oneWireBus);
DallasTemperature sensors(&oneWire);
Preferences preferences; 
WiFiManager wm;
WiFiManagerParameter custom_device_id("deviceid", "Nombre del Equipo", device_id, 50);

// NUEVO: Objeto del Amper√≠metro
Adafruit_ADS1115 ads;

// Factores de calibraci√≥n individuales del Amper√≠metro (Ajustados para carga de 8A)
float FACTOR_R = 96.44; 
float FACTOR_S = 97.47; 
float FACTOR_T = 96.83; 

void setup() {
  Serial.begin(115200);
  
  // 1. Configurar Pines 
  pinMode(PIN_COMP, OUTPUT); pinMode(PIN_EVAP, OUTPUT);
  pinMode(PIN_COND, OUTPUT); pinMode(PIN_HEAT, OUTPUT);
  pinMode(PIN_REEFER, OUTPUT);
  
  // Motores: HIGH = APAGADO (M√≥dulos Active LOW)
  digitalWrite(PIN_COMP, HIGH); digitalWrite(PIN_EVAP, HIGH);
  digitalWrite(PIN_COND, HIGH); digitalWrite(PIN_HEAT, HIGH);
  
  // REEFER MASTER (Fail-Safe):
  // HIGH = Bobina Desenergizada = Contacto NC Cerrado = REEFER ENCENDIDO (Autom√°tico)
  digitalWrite(PIN_REEFER, HIGH);

  // 2. Cargar nombre desde la memoria
  preferences.begin("reefer_config", false);
  String savedId = preferences.getString("dev_id", "");
  if(savedId != "") savedId.toCharArray(device_id, 50);
  
  // NUEVO: 3. Iniciar ADS1115 (Amper√≠metro)
  Wire.begin(21, 22); // Pines I2C (SDA, SCL)
  if (!ads.begin()) {
    Serial.println("‚ùå No se encontr√≥ el ADS1115. Revisar cables I2C.");
    // No bloqueamos con while(1) para que el ESP32 no muera si se desconecta el sensor
  } else {
    ads.setGain(GAIN_ONE); // Rango de lectura +/- 4.096V
    ads.setDataRate(RATE_ADS1115_860SPS); // M√°xima velocidad de muestreo
    Serial.println("‚úÖ Amper√≠metro ADS1115 Iniciado.");
  }

  // 4. WiFiManager (Con Timeout Anti-Bloqueo)
  wm.addParameter(&custom_device_id);
  wm.setConfigPortalTimeout(180); 
  
  bool res = wm.autoConnect("Reefer_Setup", "password123"); 

  if(!res) {
    Serial.println("Timeout del Hotspot o no hay WiFi disponible. Reiniciando...");
    ESP.restart(); 
  }
  
  // Guardar nuevo ID si el usuario lo cambi√≥ en el portal
  String newId = custom_device_id.getValue();
  if(newId != device_id && newId.length() > 0) {
      preferences.putString("dev_id", newId);
      newId.toCharArray(device_id, 50);
  }
  preferences.end();

  Serial.println("Conectado! Soy: " + String(device_id));
  ultimo_wifi_ok = millis();
  
  sensors.begin();
}

// NUEVO: Funci√≥n para leer Amperes Reales
float obtenerAmperajeRMS(int canalADS, float factor_calibracion) {
  int16_t adc_max = -32768; 
  int16_t adc_min = 32767;  
  unsigned long start_time = millis();
  
  while((millis() - start_time) < 100) {
    int16_t lectura = ads.readADC_SingleEnded(canalADS);
    if (lectura > adc_max) adc_max = lectura;
    if (lectura < adc_min) adc_min = lectura;
  }
  
  float voltaje_pico_a_pico = ((adc_max - adc_min) * 0.125) / 1000.0; 
  float voltaje_rms = (voltaje_pico_a_pico / 2.0) * 0.7071;
  float amperaje_rms = voltaje_rms * factor_calibracion;
  
  // Filtro de ruido (Ignora lecturas menores a 50mA)
  if (amperaje_rms < 0.05) return 0.0;
  
  return amperaje_rms;
}

void loop() {
  if(WiFi.status() == WL_CONNECTED) {
    
    ultimo_wifi_ok = millis(); 

    HTTPClient http;
    http.begin(serverUrl);
    http.addHeader("Content-Type", "application/json");

    // --- SENSORES TEMPERATURA ---
    sensors.requestTemperatures();
    float tempReturn = sensors.getTempCByIndex(0);
    float tempSupply = sensors.getTempCByIndex(1);
    float tempEvap = sensors.getTempCByIndex(2);
    
    // Si no detecta el sensor f√≠sico, filtramos el -127
    if(tempReturn == DEVICE_DISCONNECTED_C) tempReturn = 0.0;
    if(tempSupply == DEVICE_DISCONNECTED_C) tempSupply = 0.0;
    if(tempEvap == DEVICE_DISCONNECTED_C) tempEvap = 0.0;

    // --- SENSORES CORRIENTE (LECTURA REAL) ---
    float ampR = obtenerAmperajeRMS(0, FACTOR_R); 
    float ampS = obtenerAmperajeRMS(1, FACTOR_S); 
    float ampT = obtenerAmperajeRMS(2, FACTOR_T);

    // --- LEER ESTADO REAL (FEEDBACK RELAYS) ---
    int stComp = !digitalRead(PIN_COMP);
    int stEvap = !digitalRead(PIN_EVAP);
    int stCond = !digitalRead(PIN_COND);
    int stHeat = !digitalRead(PIN_HEAT);
    int stReefer = digitalRead(PIN_REEFER);

    // --- ARMAR JSON ---
    StaticJsonDocument<768> doc;
    doc["device_id"] = device_id;
    doc["temp_return"] = tempReturn;
    doc["temp_supply"] = tempSupply;
    doc["temp_evap"] = tempEvap;
    
    doc["amp_r"] = ampR; 
    doc["amp_s"] = ampS; 
    doc["amp_t"] = ampT;
    
    doc["rssi"] = WiFi.RSSI();
    
    doc["real_comp"] = stComp;
    doc["real_evap"] = stEvap;
    doc["real_cond"] = stCond;
    doc["real_heat"] = stHeat;
    doc["real_reefer"] = stReefer;

    String jsonStr;
    serializeJson(doc, jsonStr);

    Serial.println("Enviando: " + jsonStr);

    int code = http.POST(jsonStr);

    if(code == 200) {
      String body = http.getString();
      StaticJsonDocument<768> docRes;
      deserializeJson(docRes, body);

      // --- 1. MANTENIMIENTO REMOTO (RESET WIFI) ---
      if(docRes.containsKey("reset_wifi")) {
        int doReset = docRes["reset_wifi"];
        if(doReset == 1) {
          Serial.println("üì° ORDEN RECIBIDA: ¬°Borrando WiFi y reiniciando!");
          wm.resetSettings(); 
          delay(1000);
          ESP.restart();       
        }
      }
      
      // --- 2. CONTROL DE RELAYS ---
      int rComp = docRes["relays"]["comp"];
      int rEvap = docRes["relays"]["evap"];
      int rCond = docRes["relays"]["cond"];
      int rHeat = docRes["relays"]["heat"];
      int rReefer = docRes["relays"]["reefer"];

      if(rReefer == 1) {
        // --- MODO AUTOM√ÅTICO ---
        digitalWrite(PIN_REEFER, HIGH); 
        
        digitalWrite(PIN_COMP, HIGH);
        digitalWrite(PIN_EVAP, HIGH);
        digitalWrite(PIN_COND, HIGH);
        digitalWrite(PIN_HEAT, HIGH);

      } else {
        // --- MODO MANUAL ---
        digitalWrite(PIN_REEFER, LOW); 
        
        digitalWrite(PIN_COMP, rComp ? LOW : HIGH);
        digitalWrite(PIN_EVAP, rEvap ? LOW : HIGH);
        digitalWrite(PIN_COND, rCond ? LOW : HIGH);
        digitalWrite(PIN_HEAT, rHeat ? LOW : HIGH);
      }
    } else {
       Serial.println("Error HTTP: " + String(code));
    }
    http.end();
  } else {
    // --- WATCHDOG (PERRO GUARDI√ÅN) DE WIFI ---
    if(millis() - ultimo_wifi_ok > 300000) {
      Serial.println("‚ö†Ô∏è 5 minutos sin internet. Reiniciando ESP32 por seguridad...");
      ESP.restart();
    }
  }
  
  delay(10000); // 10 segundos para pruebas. Subir en producci√≥n.
}
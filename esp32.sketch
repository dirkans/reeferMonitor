#include <WiFiManager.h> 
#include <HTTPClient.h>
#include <OneWire.h>
#include <DallasTemperature.h>
#include <ArduinoJson.h>
#include <Preferences.h>

// --- PINES ---
const int oneWireBus = 4; 
const int PIN_COMP = 26;
const int PIN_EVAP = 27;
const int PIN_COND = 14;
const int PIN_HEAT = 12;

// RELAY MASTER (Fail-Safe: Usamos el contacto NC)
const int PIN_REEFER = 13;

// --- VARIABLES ---
char device_id[50] = "alejandra1"; 
String serverUrl = "http://10.29.92.170:8000/api/datos";

// NUEVO: Temporizador para el Watchdog (Perro Guardi치n) de WiFi
unsigned long ultimo_wifi_ok = 0; 

// --- OBJETOS ---
OneWire oneWire(oneWireBus);
DallasTemperature sensors(&oneWire);
Preferences preferences; 
WiFiManager wm;
WiFiManagerParameter custom_device_id("deviceid", "Nombre del Equipo", device_id, 50);

void setup() {
  Serial.begin(115200);
  
  // 1. Configurar Pines 
  pinMode(PIN_COMP, OUTPUT); pinMode(PIN_EVAP, OUTPUT);
  pinMode(PIN_COND, OUTPUT); pinMode(PIN_HEAT, OUTPUT);
  pinMode(PIN_REEFER, OUTPUT);
  
  // Motores: HIGH = APAGADO (M칩dulos Active LOW)
  digitalWrite(PIN_COMP, HIGH); digitalWrite(PIN_EVAP, HIGH);
  digitalWrite(PIN_COND, HIGH); digitalWrite(PIN_HEAT, HIGH);
  
  // REEFER MASTER (Fail-Safe):
  // HIGH = Bobina Desenergizada = Contacto NC Cerrado = REEFER ENCENDIDO (Autom치tico)
  digitalWrite(PIN_REEFER, HIGH);

  // 2. Cargar nombre desde la memoria
  preferences.begin("reefer_config", false);
  String savedId = preferences.getString("dev_id", "");
  if(savedId != "") savedId.toCharArray(device_id, 50);
  
  // 3. WiFiManager (Con Timeout Anti-Bloqueo)
  wm.addParameter(&custom_device_id);
  
  // NUEVO: Si levanta el Hotspot, espera m치ximo 3 minutos (180 segs). Si nadie entra, sigue de largo.
  wm.setConfigPortalTimeout(180); 
  
  bool res = wm.autoConnect("Reefer_Setup", "password123"); 

  if(!res) {
    Serial.println("Timeout del Hotspot o no hay WiFi disponible. Reiniciando...");
    ESP.restart(); // Se reinicia para no quedarse trabado
  }
  
  // Guardar nuevo ID si el usuario lo cambi칩 en el portal
  String newId = custom_device_id.getValue();
  if(newId != device_id && newId.length() > 0) {
      preferences.putString("dev_id", newId);
      newId.toCharArray(device_id, 50);
  }
  preferences.end();

  Serial.println("Conectado! Soy: " + String(device_id));
  
  // Iniciamos el temporizador indicando que ahora mismo S칈 hay WiFi
  ultimo_wifi_ok = millis();
  
  sensors.begin();
}

void loop() {
  if(WiFi.status() == WL_CONNECTED) {
    
    // Si entr칩 ac치, es porque hay internet. Actualizamos el reloj del Perro Guardi치n.
    ultimo_wifi_ok = millis(); 

    HTTPClient http;
    http.begin(serverUrl);
    http.addHeader("Content-Type", "application/json");

    // --- SENSORES ---
    sensors.requestTemperatures();
    float tempReturn = sensors.getTempCByIndex(0);
    if(tempReturn == -127) tempReturn = 20.0; 

    // Simulacion Temperaturas
    float tempSupply = tempReturn - 8.0;
    float tempEvap = (tempReturn + tempSupply) / 2.0;
    
    // --- SIMULACION CORRIENTES TRIFASICAS ---
    float ampR = 15.0; 
    float ampS = 14.5; 
    float ampT = 15.2;

    // --- LEER ESTADO REAL (FEEDBACK) ---
    // Motores: !digitalRead (invierte, si lee LOW guarda 1)
    int stComp = !digitalRead(PIN_COMP);
    int stEvap = !digitalRead(PIN_EVAP);
    int stCond = !digitalRead(PIN_COND);
    int stHeat = !digitalRead(PIN_HEAT);
    
    // Reefer: Lectura directa. Si est치 HIGH (Bobina OFF, NC Cerrado), significa 1 (ON)
    int stReefer = digitalRead(PIN_REEFER);

    // --- ARMAR JSON ---
    StaticJsonDocument<768> doc;
    doc["device_id"] = device_id;
    doc["temp_return"] = tempReturn;
    doc["temp_supply"] = tempSupply;
    doc["temp_evap"] = tempEvap;
    
    doc["amp_r"] = ampR; 
    doc["amp_s"] = ampS; 
    doc["amp_t"] = ampT;
    
    doc["rssi"] = WiFi.RSSI();
    
    doc["real_comp"] = stComp;
    doc["real_evap"] = stEvap;
    doc["real_cond"] = stCond;
    doc["real_heat"] = stHeat;
    doc["real_reefer"] = stReefer;

    String jsonStr;
    serializeJson(doc, jsonStr);

    int code = http.POST(jsonStr);

    if(code == 200) {
      String body = http.getString();
      StaticJsonDocument<768> docRes;
      deserializeJson(docRes, body);

      // --- 1. MANTENIMIENTO REMOTO (RESET WIFI) ---
      // Verificamos si el servidor nos mand칩 la orden de borrar el WiFi
      if(docRes.containsKey("reset_wifi")) {
        int doReset = docRes["reset_wifi"];
        if(doReset == 1) {
          Serial.println("游니 ORDEN RECIBIDA: 춰Borrando WiFi y reiniciando!");
          wm.resetSettings();  // Borra la clave de WiFi
          delay(1000);
          ESP.restart();       // Se reinicia. Levantar치 el Hotspot autom치ticamente.
        }
      }
      
      // --- 2. CONTROL DE RELAYS ---
      int rComp = docRes["relays"]["comp"];
      int rEvap = docRes["relays"]["evap"];
      int rCond = docRes["relays"]["cond"];
      int rHeat = docRes["relays"]["heat"];
      int rReefer = docRes["relays"]["reefer"];

      if(rReefer == 1) {
        // --- MODO AUTOM츼TICO ---
        digitalWrite(PIN_REEFER, HIGH); // Bobina Desenergizada (NC Cerrado)
        
        // BLOQUEO cruzado: Forzamos el apagado de los motores manuales
        digitalWrite(PIN_COMP, HIGH);
        digitalWrite(PIN_EVAP, HIGH);
        digitalWrite(PIN_COND, HIGH);
        digitalWrite(PIN_HEAT, HIGH);

      } else {
        // --- MODO MANUAL ---
        digitalWrite(PIN_REEFER, LOW); // Bobina Energizada (NC Abierto -> Corta controlador original)
        
        // LIBERACI칍N: Obedecemos a los botones manuales (1 = LOW/Tomado, 0 = HIGH/Suelto)
        digitalWrite(PIN_COMP, rComp ? LOW : HIGH);
        digitalWrite(PIN_EVAP, rEvap ? LOW : HIGH);
        digitalWrite(PIN_COND, rCond ? LOW : HIGH);
        digitalWrite(PIN_HEAT, rHeat ? LOW : HIGH);
      }
    }
    http.end();
  } else {
    // --- WATCHDOG (PERRO GUARDI츼N) DE WIFI ---
    // Si no hay WiFi, revisamos hace cu치nto perdimos la conexi칩n.
    // 300000 milisegundos = 5 minutos.
    if(millis() - ultimo_wifi_ok > 300000) {
      Serial.println("丘멆잺 5 minutos sin internet. Reiniciando ESP32 por seguridad...");
      ESP.restart();
    }
  }
  
  delay(5000); 
}